:toc: macro
toc::[]

= Task Service - Data Access Layer

In this chapter we are going to create database schema with initial data.
Then we will map it into entities model and provide operations for management of the entities.

== Create your component

After you have completed your own link:build-devon4j-application.asciidoc[devon4j app creation] [.red]#>>TODO app creation link update<<#, we are going to create our first app component.

Going back to our example application, link:order-service.asciidoc[Order Service] >>TODO update link here<<, we need to provide basic functionalities:

[.red]>>#TODO update functionalities<<#

- increase price of the item with specified name.
- remove customer by id.
- create order with two positions and owner specified.
- find orders from given day with specified status.
- find items by name match (LIKE) ordered by name.

To accomplish that we are going to work over three entities: _PersonEntity_, _TaskItemEntity_, _TaskListEntity_.

[.red]#>>TODO update image<<#

image::images/devon4j/6.Dataaccess/orderservice_entity_schema.png[width="700", link="images/devon4j/6.Dataaccess/orderservice_entity_schema.png"]

Each of the entities will have autogenerated id and version which specifies version number of the entity.

The TaskListEntity will be defined with name. It will also have a collection of tasks (TaskItemEntities).

The TaskItemEntity will be defined with: name, completed (true of false) and a deadline. It will have a TaskListEntity, that it belongs to.

The PersonEntity will be defined with an email. It will also hold an information, which task list it has assigned (TaskListEntity).

This means, we will have to represent two relationships:

The one to many relation between the task list and task items.

The one to one relation between a person and a task list.

=== The database

For the sake of the training we will be working with H2 database engine to create our database schema.
We will be using flyway to migrate our database scheme.

You can check that your schema is valid running TodoAppApplication.java which recreates schema after each run. Created schema can be found in the H2 console.

[.red]#>>TODO update image<<#

image::images/devon4j/6.Dataaccess/orderservice_db_schema.png[width="700", link="images/devon4j/6.Dataaccess/orderservice_db_schema.png"]

Lets start with the database schema. Create a new sql file _V0001__Create_schema.sql_ in todo-app/src/main/resources/db/migration/1.0/ folder.
At the very beginning lets add:
CREATE SEQUENCE HIBERNATE_SEQUENCE START WITH 1000000;
which will allow us to safely add some test data later on.

==== _TASK_LIST_ table

We will add our first table TASK_LIST in /todo-app/src/main/resources/db/migration/1.0/V0001__Create_schema.sql. In the case of TaskService, the items will provide: id, version and name. So we need to represent that data in our table:

[source,sql]
----
CREATE TABLE TASK_LIST (
ID NUMBER(19,0) NOT NULL AUTO_INCREMENT,
VERSION INTEGER NOT NULL,
NAME VARCHAR(256),
PRIMARY KEY (ID)
);
----

- ID: the id for each item, automatically incremented using sequence HIBERNATE_SEQUENCE.
- VERSION: used internally by JPA to take care of the optimistic locking for us.
- NAME: the task list's name.

We will also set the constraints:
- primary key for id to take care of it's uniqueness.

==== _TASK_ITEM_ table
Basing on _TASK_LIST_ table lets provide also _TASK_ITEM_ table. This time we will have to add a foreign key, which will describe the relation between these two tables. _TASK_ITEM_ table will be created with attributes as follows:

- ID: the id for each customer, automatically incremented using sequence HIBERNATE_SEQUENCE.
- VERSION: used internally by JPA to take care of the optimistic locking for us.
- NAME: the task's name.
- COMPLETED: the information whether the task was completed in form of a number: 1 as true, 0 as false, with default value being equal to 0.
- DEADLINE: a time by which the task needs to be done, as a timestamp.
- TASK_LIST_ID: the id of a TASK_LIST entry, to which the TASK_ITEM belongs to.

We will also set the constraints:
- primary key for ID to take care of it's uniqueness.
- foreign key for TASK_LIST_ID referencing the _TASK_LIST_ Table, describing the relationship between the Task Item and the List.

Please create this table definition basing on types and specific column names that are shown in the diagram.

==== _PERSON_ table
Basing on _TASK_LIST_ table we will provide the _PERSON_ Table as well. Similar to _TASK_ITEM_, _PERSON_ will also contain a foreign key to _TASK_LIST_ table, which will describe a relationship between the two. The attributes we need to provide are as follows:

- ID: the id for each order, automatically incremented using sequence HIBERNATE_SEQUENCE.
- VERSION: used internally by JPA to take care of the optimistic locking for us.
- EMAIL: an email of the Person
- TASK_LIST_ID: the id of a TASK_LIST entry, to which the PERSON is assigned.

We will also set the constraints:
- primary key for ID to take care of it's uniqueness.
- foreign key for TASK_LIST_ID referencing the _TASK_LIST_ Table, describing the relationship between the Person and the Task List.

[source,sql]
----
CREATE TABLE PERSON (
ID NUMBER(19,0) NOT NULL AUTO_INCREMENT,
VERSION INTEGER NOT NULL,
EMAIL VARCHAR(256) NOT NULL,
TASK_LIST_ID NUMBER(19,0),
PRIMARY KEY (ID),
FOREIGN KEY (TASK_LIST_ID) REFERENCES TASK_LIST(ID)
);
----

==== Mock data 

[.red>>TODO fix the description from here on<<#

Finally we can provide a certain amount of mock data to start our app. Add a new sql script /order-service-core/src/main/resources/db/migration/1.0/V0003__Add_OrderServiceData.sql adding sample data:

[source,sql]
----
INSERT INTO Item(id, ModificationCounter, name, description, price) VALUES (21, 0, 'spaghetti bolognese', 'Italy', 250);

INSERT INTO Customer(id, ModificationCounter, firstname, lastname) VALUES (31, 0, 'John', 'Travolta');

INSERT INTO OrderSummary(id, ModificationCounter, price, ownerId, creationDate, status) VALUES (41, 0, 671.10, 31, '2019-03-15', 'SERVED');

INSERT INTO OrderPosition(orderId, itemId) VALUES (41, 21);
----

You can provide your own data or use script which can be found here.

Run application and check that the data you provided is inserted into the database.

=== Entities
Now that we have defined the data base for our entities is the moment to start creating the code of the related components.

We are going to create entities with it's interfaces in new package _orderservice_ which will contain all objects specific for our application.

In order-service-core component create package _orderservice.dataaccess.api_ under com.devonfw.app.java.order where we will place our entities.

image::images/devon4j/6.Dataaccess/new_package.png[width="700", link="images/devon4j/6.Dataaccess/new_package.png"]
image::images/devon4j/6.Dataaccess/orderservice_package.PNG[width="700", link="images/devon4j/6.Dataaccess/orderservice_package.PNG"]

==== ItemEntity

Create new class ItemEntity.

image::images/devon4j/6.Dataaccess/itementity.PNG[width="700", link="images/devon4j/6.Dataaccess/itementity.PNG"]

Create there private attributes basing on the schema. For now, skip id and modificationCounter.
For each of them generate getters and setters (right click in ItemEntity -> Source -> Generate Getters and Setters).

Mark table with @Entity annotation and set also table name which should be mapped to this object.

[source,java]
----
@Entity(name="Item")
public class ItemEntity {
----

Generate interface and class hierarchy for _ItemEntity_ using CobiGen.

image::images/devon4j/6.Dataaccess/generateentity.png[width="700", link="images/devon4j/6.Dataaccess/generateentity.png"]

Choose Entity Infrastructure and click finish.

image::images/devon4j/6.Dataaccess/generate_entity_infrastructure.PNG[width="700", link="images/devon4j/6.Dataaccess/generate_entity_infrastructure.PNG"]

[source,java]
----
@Entity(name="Item")
public class ItemEntity extends ApplicationPersistenceEntity implements Item {
----

_ItemEntity_ extends now _ApplicationPersistenceEntity_ which has attributes id and modificationCounter needed for all our entities. Each of the entities should inherit from this class.

Check implementation of _ApplicationPersistenceEntity_,
[source,java]
----
@Override
@Id
@GeneratedValue(strategy = GenerationType.AUTO)
public Long getId() {

  return this.id;
}

@Override
@Version
public int getModificationCounter() {

  return this.modificationCounter;
}
----

- @Id shows that this attribute will be the identifier of the entity. It is used by JPA to identify entity.
- @GeneratedValue shows that values for id will be automatically generated
- @Version defines modificationCounter attribute as version counter.

In component order-service-api com.devonfw.app.java.order.orderservice.common.api.Item, there is Item interface generated which contains method which have to be implemented by the Entity and later by transfer objects.

You can run the application and it should start correctly.

==== CustomerEntity

Next to the _ItemEntity_ create _CustomerEntity_ which should inherit from _ApplicationPersistenceEntity_.
Prepare attributes as shown in the schema (skip orders attribute until we create OrderEntity).
Generate getters and setters.
Generate  _Customer_ interface for the entity same way we did it for _ItemEntity_.

==== OrderEntity

In component order-service-api com.devonfw.app.java.order.orderservice.common.api create _OrderStatus_ enum which will be used as status in _OrderEntity_.
[source,java]
----
public enum OrderStatus {
	NEW, PREPARING, PREPARED, SERVED, PAID, CANCELLED
}
----

Next to other entities create _OrderEntity_. It should also inherit from _ApplicationPersistenceEntity_.
Prepare attributes as shown in the schema.
Generate getters and setters.
Generate  _Order_ interface for the entity.

Above getters add needed annotations:

- As default, enum values are saved as Integer in the database. To have it's value as String, change is needed:
+
[source,java]
----
@Enumerated(EnumType.STRING)
public OrderStatus getStatus() {
  return status;
}
----
- Add mapping for relation to _CustomerEntity_:
+
[source,java]
----
@ManyToOne
@JoinColumn(name = "ownerId")
public CustomerEntity getOwner() {
  return owner;
}
----
- Check method getOwnerId, it is marked with @Transient annotation to not map owner twice (since we have relation specified also by getOwner() method):
+
[source,java]
----
@Transient
	public Long getOwnerId() {
		if (this.getOwner() != null)
			return this.getOwner().getId();
		return null;
	}

	public void setOwnerId(Long ownerId) {
		CustomerEntity e = new CustomerEntity();
		e.setId(ownerId);
		this.setOwner(e);
	}
----
- Add mapping for relation to _ItemEntity_:
+
[source,java]
----
@ManyToMany
@JoinTable(name = "OrderPosition", joinColumns = @JoinColumn(name = "orderId", referencedColumnName = "id"), inverseJoinColumns = @JoinColumn(name = "itemId", referencedColumnName = "id"))
public Set<ItemEntity> getOrderPositions() {
  return orderPositions;
}
----
Adjust _CustomerEntity_ and add there relation to _OrderEntity_ with annotation showing that this relation is mapped only in OrderSummary table.
+
[source,java]
----
@OneToMany(mappedBy = "owner")
public Set<OrderEntity> getOrders() {
  return orders;
}
----

Run application and check that schema from database maps correctly into entities model.

=== Repositories

To perform operations on our entities we need to create repositories for each of them. They will contain operations specific for each of the objects.

==== ItemRepository

In component order-service-core, create package com.devonfw.app.java.order.orderservice.dataaccess.api.repo. We will place there all our repositories.

Create interface _ItemRepository_. It should extend _DefaultRepository_ from JPA which contains generic operations for entities.
[source,java]
----
public interface ItemRepository extends DefaultRepository<ItemEntity> {
----

==== ItemRepositoryTest

With such repository we can already perform basic CRUD operations, f.e. save, deleteById, findById.

We will test the behaviour of Repository methods using unit tests.

In source folder src/test/java of component order-service-core create same package as for interface.

Create there class _ItemRepositoryTest_
[source,java]
----
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;

@SpringBootTest( webEnvironment = WebEnvironment.DEFINED_PORT)
public class ItemRepositoryTest extends ComponentTest {
----

DEFINED_PORT is used to connect to H2 console always on the specified port.
We need to adjust application.properties of src/test/resources/config.

- Enable there h2 console
- Adjust spring.datasource.url to be same as for our application
- Define server.port as different than for application.
- Look at spring.flyway.locations. It calls migration of data for each of test runs. We leave it for now to start with the filled database.

[source]
----
server.port=8085
spring.h2.console.enabled=true
----

Functionality of ComponentTest will be described later.

===== FindAll test

Let's write our first test - we would like to find all items. We will use for it JpaRepository.findAll() method which is available in _ItemRepository_ thanks to inheritance of DefaultRepository.

- inject _ItemRepository_ to test class.
- prepare public method annotated with _@Test_
- call there _ItemRepository.findAll()_ method
- check that number of found elements is same as number of elements created in your migration.

[source,java]
----
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;

@SpringBootTest( webEnvironment = WebEnvironment.DEFINED_PORT)
public class ItemRepositoryTest extends ComponentTest {

  @Inject
  private ItemRepository itemRepository;

  @Test
  public void shouldFindAllItems() {
    // when
    List<ItemEntity> foundItems = itemRepository.findAll();

    // then
    assertThat(foundItems).hasSize(1);
  }
----

Run test

image::images/devon4j/6.Dataaccess/run_junit.png[width="700", link="images/devon4j/6.Dataaccess/run_junit.png"]

To check that items from migrations are really in the tested database, create a breakpoint in the test. It will pause the

Congratulations, you wrote your first unit test!

==== JPAQuery

QueryDSL allows us to write query which can be suitable for many use cases.

Create search criteria object which will contain all arguments used in this query. Place it on order-service-api in package com.devonfw.app.java.order.orderservice.logic.api.to
_ItemSearchCriteriaTo_ has to contain all business attributes of _ItemEntity_.
Additionally we add there _StringSearchConfigTo_ for each of the string attributes to be able to create also LIKE expressions.

[source,java]
----
import org.springframework.data.domain.Pageable;

public class ItemSearchCriteriaTo extends AbstractTo {

  private String name;
  private String description;
  private Double price;
  private StringSearchConfigTo nameOption;
  private StringSearchConfigTo descriptionOption;
  private Pageable pageable;
----

Implement getters and setters for all attributes.

Go back to the _ItemRepository_. Implement there findByCriteria method using JPAQuery.
[source,java]
----
import static com.querydsl.core.alias.Alias.$

default Page<ItemEntity> findByCriteria(ItemSearchCriteriaTo criteria) {

  ItemEntity alias = newDslAlias();
  JPAQuery<ItemEntity> query = newDslQuery(alias);

  String name = criteria.getName();
  if (name != null && !name.isEmpty()) {
    QueryUtil.get().whereString(query, $(alias.getName()), name, criteria.getNameOption());
  }

  // TODO: implement also expression for description and price

  // TODO: implement also sorting using addOrderBy

  // TODO: return found items using QueryUtil
}
----

Test the solution you created.

===== Hints

[source,java]
----
Sort sort = Sort.by("name");
Pageable pageable = PageRequest.of(0, 20, sort);
----

==== Repositories with CobiGen

For OrderEntity and CustomerEntity we will generate SeachCriteria and Repositories using CobiGen.
Right click on each of the entities, generate with CobiGen. Mark there TO's ans SpringRepository.
Click Customize (right down corner of objects generated) and untick TO object (CustomerTo).

image::images/devon4j/6.Dataaccess/generaterepo.PNG[width="700", link="images/devon4j/6.Dataaccess/generaterepo.PNG"]

Compare generated repositories to your own.

==== Business functionality

Implement given queries together with unit tests.

- Find item entities where name is like given argument (case insensitive). Sort result by name ascending - use search criteria query.
- Find orders from given day with specific status - create SpringData query.
- Remove Customer by id.
- Create Order with two order positions and owner set.
- Update item with given name changing it's price.

===== Remark

During testing ItemEntity we used our migration to create testdata. Instead of it, we should create testdata for each unit test separately to have them independent.
To do so, after each of the tests, we will clear database schema using _doTearDown()_ method.
[source,java]
----
@Override
protected void doTearDown() {
  super.doTearDown();
  // TODO: call here delete for all entities related to this test class
  this.itemRepository.deleteAll();
}
----

We won't load data from our migration file. Please adjust application.properties file from test directory and remove there migration location from flyway locations.

[source,properties]
----
spring.flyway.locations=classpath:db/type/h2
----

=== link:order-service-logic-layer.asciidoc[Next chapter: Order Service - Business Logic Layer]
