:toc: macro
toc::[]

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

= Order Service -Security

In this chapter we are going to configure authentication and authorization for our services. We will learn how to create permission and roles, how to grant theme and how to apply these permisions to business logic.

== Basic configuration

Basic security configuration in application is already done. It was created at the very begining, during creation of application from archetype. You can find many interesting informations in following classes:
[source,java]
----
com.devonfw.app.java.order.general.service.impl.config.BaseWebSecurityConfig
com.devonfw.app.java.order.general.common.impl.security.BaseUserDetailsService
----

Please read these files carefully and try to understand what is configured there. Find out where and how users and its roles (permissions) are set in application during authorization process. Consider if it will be enough in future (hint: find TODO in a code).

== Authorization

Authorization can be done in multiple ways. Spring by default base on so called user roles. User has assigned some roles and based on then we can allowe/deny some functionality. Sometimes it is not enough. We don't want to do it by entire role but a using simply small permission which can be assigned to some groups. This framework already provide for us such a functionality.

=== Access Control Config
In this method roles and assigned to theme permission are configured in the code. We are able to inheritance from other group as well as define new ones. In generated project basic configuration can be found under:
----
com.devonfw.app.java.order.general.common.api.security.ApplicationAccessControlConfig
----

For more details please see:
https://github.com/devonfw/devon4j/wiki/guide-access-control#access-control-config

=== Access Control Schema (Deprecated - Please don't do it, just for information)
This is second possible approach. It was designed oginally but now it is deprecated. Idea is the same as in previous method. The only difference is that all roles/groups and so on are configured in file *access-control-schema.xml*. After configuration constant values for theme can be generated by cobigen to class PermissionConstants.

More details about this methods can be found under:
https://github.com/devonfw/devon4j/wiki/guide-access-control#access-control-schema-deprecated

== Exercises

. Basic configuration of authorization.

* Your first task is to create user groups and permissions to already implemented logic. Think about prepared use cases, roles present in system and decide which role should contain what permissions. After that prepare you permission schema appropriate using Access Control Config method. To do that please class ApplicationAccessControlConfig appropriately. Description and examples you can find in link in description of that method. Please remember about meaningfull and correct naming.
** Please remember to use inheritance of permissions to avoid duplications.
* Currently application is configured to use access-control-schema.xml (deprecated method). To chang it please modify field *BaseUserDetailsService->accessControlProvider* to appropriate type - *ApplicationAccessControlConfig*.
* Now you are ready to actually protect your business logic. Grant access to the desired group of users putting *@RolesAllowed* annotation with appropiate permission in class *OrderserviceImpl*.
* Please implement method BaseUserDetailsService->getRoles to retrieve actual roles from user. Current implementation gives user always one authority - its name. You need to read user by username and read its Authorities (they are of type *GrantedAuthority* - to receive string you need to invoke GrantedAuthority->getAuthority). Please note that roles are camel case.
* Run application and check if everything works. You should receive a forbidden message for operations for which user has no permission. In other case it should be executed correctly.
+
TIP: Please look how exactly users and its roles/authorities are configured and how this values are translated to actual permissions defined before. You can do it in class BaseWebSecurityConfig->configureGlobal (defining users) and BaseUserDetailsService->getRoles.
+
WARNING: Please remember that when you are defining a role by *.roles("Waiter")* then this user contains authority with prefix ROLE_ (in this case ROLE_Waiter). Please take it into consideration when implementing BaseUserDetailsService->getRoles. Another option is to use .**authorities**("Waiter") instead to avoid adding prefix.

== Additional Exercises

. So far all data about users were held in memory. Now try to use database to hold your users. Adjust appropriate component to receive data from database during authentication.
* Create appropriate migration script which add users and roles.
* Change method configureGlobal in class BaseUserDetailsService to use database.
* Verify that after addition of new user to database you can log in using new creaditentials.
+
. **Extend your application that user can additionally use some header token or cookie value to authenticate (token value may be username - same as on example during presentation). You can base on JsonUsernamePasswordAuthenticationFilter to do that
